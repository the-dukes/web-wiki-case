import{_ as e,o as s,c as n,a}from"./app-d6eaa58c.js";const o={},t=a(`<h1 id="_08-fetchapi" tabindex="-1"><a class="header-anchor" href="#_08-fetchapi" aria-hidden="true">#</a> 08-FetchApi</h1><h2 id="fetch-api-概述" tabindex="-1"><a class="header-anchor" href="#fetch-api-概述" aria-hidden="true">#</a> Fetch Api 概述</h2><p><strong>XMLHttpRequest 的问题？</strong></p><ol><li><p>所有的功能全部集中在同一个对象上，容易书写出混乱不易维护的代码</p></li><li><p>采用传统的事件驱动模式，无法适配新的 Promise Api（<strong>无法返回新的 Promise</strong>）</p></li></ol><p><strong>Fetch Api 的特点：</strong></p><ol><li><p>并非取代 AJAX，而是对 AJAX 传统 API 的改进</p></li><li><p>精细的功能分割</p></li></ol><blockquote><p><code>头部信息、请求信息、响应信息</code>等均分布到不同的对象，更利于处理各种复杂的 AJAX 场景</p></blockquote><ol><li><p>使用 Promise Api，更利于异步代码的书写</p></li><li><p>Fetch Api 并非 ES6 的内容，属于 HTML5 新增的 Web Api</p></li></ol><blockquote><p>Fetch 属于浏览器环境，在浏览器环境中使用。</p></blockquote><ol><li>需要掌握网络通信的知识</li></ol><h2 id="使用-fetch-api" tabindex="-1"><a class="header-anchor" href="#使用-fetch-api" aria-hidden="true">#</a> 使用 Fetch Api</h2><h2 id="fetch-函数" tabindex="-1"><a class="header-anchor" href="#fetch-函数" aria-hidden="true">#</a> fetch 函数</h2><p><strong>fetch 函数：</strong></p><blockquote><p>使用 <code>fetch</code> 函数即可立即向服务器发送网络请求。</p></blockquote><h2 id="参数" tabindex="-1"><a class="header-anchor" href="#参数" aria-hidden="true">#</a> 参数</h2><p><strong>fetch(url, options)</strong>：</p><ul><li>url</li></ul><blockquote><p>必填，字符串，请求地址。</p></blockquote><ul><li>opstions</li></ul><blockquote><p>选填，请求配置。</p></blockquote><p><strong>请求配置对象：</strong></p><ul><li>method：字符串，请求方法，默认值 GET。</li><li>headers：对象，请求头信息</li><li>body: 请求体的内容，必须匹配请求头中的 Content-Type。（post 方式请求参数放在请求体,get 方式请求参数放在 url)</li><li>mode：字符串，请求模式</li></ul><blockquote><p>cors：默认值，配置为该值，会在请求头中加入 origin 和 referer。（解决跨域）</p><p>no-cors：配置为该值，不会在请求头中加入 origin 和 referer，跨域的时候可能会出现问题</p><p>same-origin：指示请求必须在同一个域中发生，如果请求其他域，则会报错</p></blockquote><ul><li>credentials: 如何携带凭据（cookie）</li></ul><blockquote><p>omit：默认值，不携带 cookie</p><p>same-origin：请求同源地址时携带 cookie</p><p>include：请求任何地址都携带 cookie</p></blockquote><ul><li>cache：配置缓存模式</li></ul><blockquote><p>default: 表示 fetch 请求之前将检查下 http 的缓存.</p><p>no-store: 表示 fetch 请求将完全忽略 http 缓存的存在. 这意味着请求之前将不再检查下 http 的缓存, 拿到响应后, 它也不会更新 http 缓存。</p><p>no-cache: 如果存在缓存, 那么 fetch 将发送一个条件查询 request 和一个正常的 request, 拿到响应后, 它会更新 http 缓存。</p><p>reload: 表示 fetch 请求之前将忽略 http 缓存的存在, 但是请求拿到响应后, 它将主动更新 http 缓存。</p><p>force-cache: 表示 fetch 请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 除非没有任何缓存, 那么它将发送一个正常的 request。</p><p>only-if-cached: 表示 fetch 请求不顾一切的依赖缓存, 即使缓存过期了, 它依然从缓存中读取. 如果没有缓存, 它将抛出网络错误(该设置只在 mode 为”same-origin”时有效)。</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">&#39;POST&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">&#39;Content-Type&#39;</span><span class="token operator">:</span> <span class="token string">&#39;application/json&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">body</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="返回值" tabindex="-1"><a class="header-anchor" href="#返回值" aria-hidden="true">#</a> 返回值</h2><p><strong>fetch 函数</strong>返回一个 Promise 对象：</p><ul><li>当收到服务器的返回结果后，Promise 进入 resolved 状态，状态数据为 Response 对象</li><li>当网络发生错误（或其他导致无法完成交互的错误）时，Promise 进入 rejected 状态，状态数据为错误信息</li></ul><p><strong>Response 对象：</strong></p><ul><li>ok</li></ul><blockquote><p>boolean，当响应消息码在 200~299 之间时为 true，其他为 false</p></blockquote><ul><li>status</li></ul><blockquote><p>number，响应的状态码</p></blockquote><ul><li><code>text()</code></li></ul><blockquote><p>用于处理文本格式的 Ajax 响应。它从响应中获取文本流，将其读完，然后返回一个被解决为 string 对象的 Promise。</p></blockquote><ul><li><code>blob()</code></li></ul><blockquote><p>用于处理二进制文件格式（比如图片或者电子表格）的 Ajax 响应。它读取文件的原始数据，一旦读取完整个文件，就返回一个被解决为 blob 对象的 Promise。</p></blockquote><ul><li><code>json()</code></li></ul><blockquote><p>用于处理 JSON 格式的 Ajax 的响应。返回将 JSON 数据流转换为一个被解决为 JavaScript 对象的 promise。</p></blockquote><ul><li>redirect()</li></ul><blockquote><p>可以用于重定向到另一个 URL。它会创建一个新的 Promise，以解决来自重定向的 URL 的响应。</p></blockquote><h2 id="request-对象" tabindex="-1"><a class="header-anchor" href="#request-对象" aria-hidden="true">#</a> Request 对象</h2><p><strong>fetch(Request 对象)：</strong></p><blockquote><p>除了使用基本的 fetch 方法，还可以通过创建一个 Request 对象来完成请求。</p><p>（实际上，fetch 的内部会帮你创建一个 Request 对象）<code>new Request(url地址, 配置)</code> 。 ** &gt; ** 注意：尽量保证每次请求都是一个新的 Request 对象。</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token string">&#39;http://101.132.72.36:5100/api/local&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> resp1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> resp2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>clone</li></ul><blockquote><p><code>req.clone();</code> 克隆一个全新的 Request 对象，配置一致。</p></blockquote><h2 id="response-对象" tabindex="-1"><a class="header-anchor" href="#response-对象" aria-hidden="true">#</a> Response 对象</h2><p><strong>创建 Response 对象：</strong></p><blockquote><p>(响应体数据， 配置对象)</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span><span class="token string">&#39;[{&quot;id&quot;: 1, &quot;name&quot;: &quot;BJ&quot;}]&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">ok</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">status</span><span class="token operator">:</span> <span class="token number">200</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="header-对象" tabindex="-1"><a class="header-anchor" href="#header-对象" aria-hidden="true">#</a> Header 对象</h2><p>在 Request 和 Response 对象内部，会将传递的请求头对象，转换为 Headers 对象。</p><p><strong>Headers 对象中的方法：</strong></p><ul><li>has(key)</li></ul><blockquote><p>检查请求头中是否存在指定的 key 值</p></blockquote><ul><li>get(key)</li></ul><blockquote><p>得到请求头中对应的 key 值</p></blockquote><ul><li>set(key, value)</li></ul><blockquote><p>修改对应的键值对</p></blockquote><ul><li>append(key, value)</li></ul><blockquote><p>添加对应的键值对</p></blockquote><ul><li>keys():</li></ul><blockquote><p>得到所有的请求头键的集合</p></blockquote><ul><li>values():</li></ul><blockquote><p>得到所有的请求头中的值的集合</p></blockquote><ul><li>entries():</li></ul>`,70),p=[t];function l(c,i){return s(),n("div",null,p)}const u=e(o,[["render",l],["__file","08-FetchApi.html.vue"]]);export{u as default};
